#+STYLE: <style>
#+STYLE: body {font-family:Verdana,Arial,Helvetica,sans-serif;font-size:90%;}
#+STYLE: 
#+STYLE: </style>

#+TITLE: Internals

* Request processing workflow
 
1. Request catched by webserver. It handles static resources.

2. If request not processed, it processed by web server interface
   (currently it's only ~s_platform_inets~ for inets server. This
   interface extracts GET and POST parameters and executes ~s_dispatcher:dispatch()~

3. ~s_dispatcher~ routes request (using ~s_route.parse_request~) 

   1. If requested controller not exists, 404 page rendered

4. Requested controller executes

   1. If controller fails, error page rendered

5. View requested by controller renders
   
   1. 404 page renders if view not found

   2. Error page renders if render fails

6. Response converts to web server specific form and renders.

* Routing

Routing file is set of records, that describe routes. Following routes
supported:

#+BEGIN_SRC erlang
{Path, [Params]} % Page route

{Method, Path, [Params]} % RESTful page route
#+END_SRC

- Difference between ={Path, [Params]}= is the same as ={any, Path, [Params]}=.

- Path can be atom '~root~'. In this case it's matches root route.

- Path in routes can have wildcard components: For example route
  "~test/:id~" will match "~test/123~" path (and request will be
  routed with parameter ~id~ equals to "~123~")

* Directory structure

#+BEGIN_EXAMPLE
  app
    \controllers
    \views
  bin
  config
  lib
  logs
  public
  tmp
#+END_EXAMPLE
  
 - *app/controllers* directory contains controllers. Currently
   controllers have no namespaces
 - *app/views* directory contains views. Template engine identified by
   view extension.
 - *app/ebin* used internally for compiled controllers/views
 - *bin* directory contains useful scripts (currently only for startup
   server)
 - *config* directory contains:
   - *application.conf* is main configuration file. You can read
     configuration options description [[application.conf description][here]] details 
   - *routes.conf* is file with routing configuration. You can read
     about file format [[routes.conf description][here]].
 - *lib* directory with Erlang OTP applications (such steroids
   framework, erlydtl templating engine, etc)  
 - *logs* directory contains application logs
 - *public* directory contains static files (images, stylesheets, etc)
 - *tmp* directory contains temporary stuff like uploaded files

* Reloader

This subsystem used for reload different kind of files:

1. Controllers

2. Views

It's automatically checks if file changed and executes ~compile~
function if reload required. For work it used callback module with
following interface:

#+BEGIN_SRC erlang
compile_and_load(RealPath, TargetModule)

get_real_path(Path)

get_module_name(Path)
#+END_SRC

- ~get_module_name~ returns module name, for specific (virtual)
  path. F.e. it's generate module name for path to template.

- ~get_real_path~ returns file system path to specified virtual
  path. F.e. real file path for template.

- ~compile_and_load~ compiles file on specified real path to ~Module~.

* Template engine integration

You can easy integrate your template engine:

** Step 1. Adapter creating

You should create adapter with following interface:


#+BEGIN_SRC erlang
compile(Path, Module)
#+END_SRC

- ~compile~ function compiles template with absolute path ~Path~ to ~Module~

Also you should add your template to config file:

#+BEGIN_SRC erlang -n
config/application.conf
{template_engines, [
                    {s_erlydtl_adapter, ["dtl"]}
                   ]}.
#+END_SRC

It's list of pairs: template engine module name with list of
extensions for this template engine.
